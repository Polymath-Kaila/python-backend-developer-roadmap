# chapter 1: The python Data model
1. Dunder methods
2. Protocol thinking
3. How objects integrates with python
4. Why Python feels consistent

---

# chapter 2: An array of sequnce
1. List comprehensions vs genexps
2. Tuple unpacking
3. Sequence behaviours
4. When to use which sequence type
5. Pythonic data transformations

---

# chapter 3: Dictionaries and sets
1. Hash tables
2. key-value behaviours
3. sets for uniqueness
4. backend uses cases

---

# chapter 4: Text vs Bytes
1. Unicode vs bytes
2. Encoding vs decoding
3. File I/O
4. Buffer protocol

---

# chapter 5: First class functions
1. Functions as objects
2. Higher order functions
3. Closures
4. Decorators
5. Collable objects
6. Functions introspection
7. Lambda functions

---

# chapter 6: Design patters with First class functions
1. Funcions-based strategies
2. Replacing classes with functions
3. Decorators patterns
4. Collable vs closures
5. Frameworks-style logic

---

# chapter 7: Function Decorators and closures
1. Decorator mechanics
2. Decorator factories
3. State preservatio
4. `functools.wraps`
5. Class-based decorators

---

# chapter 8: Object refrences, Mutability, and Recycling
1. Object identity
2. Mutability vs immutability
3. Aliasing
4. Garbege collection
5. Object lifetime
6. Bugs in shared state

---
# chapter 9: A pythonic object
1. Properties
2. Descriptors
3. `__slots__`
4. Weak refrences
5. Object protocols
6. How frameworks are built

---

# chapter 10: sequence hacks, hashing and slicing
1. Sequence protocol
2. ` __getitem__`
3. Slice objects
4. Lazy evaluation
5. Hashing & equality
6. Ordering
7. Mutation vs rebinding
8. Idiomatic sequence transformations

---

# chapter 11: Interfaces,Protocols & ABCs
# chapter 12: Iterators & Generators
# chapter 13: Operator Overloading
# chapter 14: Iterables, Iterators, Generators
# chapter 15: Context Managers
# chapter 16: Coroutines & async
# chapter 17: Concurrency
# chapter 18: Metaprogramming
